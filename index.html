<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Modern Hand HUD</title>
	<link rel="preconnect" href="https://cdn.jsdelivr.net" />
	<link rel="stylesheet" href="js.css " />
</head>
<body>
	<div id="app">
		<video id="webcam" playsinline autoplay muted></video>
		<canvas id="overlay"></canvas>
		
		<!-- Modern UI Controls -->
		<div id="controls-panel">
			<div class="glass-card">
				<h3 class="panel-title">Hand Tracking HUD</h3>
				<div class="control-group">
					<button id="startBtn" class="modern-btn primary">
						<span class="btn-icon">ðŸ“·</span>
						Enable Camera
					</button>
					<select id="modeSelect" class="modern-select" title="Performance Mode">
						<option value="speed">âš¡ Speed Mode</option>
						<option value="quality">ðŸ’Ž Quality Mode</option>
					</select>
				</div>
				
				<div class="status-indicators">
					<div class="status-item">
						<span class="status-dot" id="camera-status"></span>
						<span>Camera</span>
					</div>
					<div class="status-item">
						<span class="status-dot" id="detection-status"></span>
						<span>Detection</span>
					</div>
				</div>
			</div>
		</div>
		
		<!-- Info Panel -->
		<div id="info-panel">
			<div class="glass-card">
				<div class="info-item">
					<span class="info-label">FPS</span>
					<span class="info-value" id="fps-counter">0</span>
				</div>
				<div class="info-item">
					<span class="info-label">Hands</span>
					<span class="info-value" id="hand-counter">0</span>
				</div>
				<div class="info-item">
					<span class="info-label">Mode</span>
					<span class="info-value" id="mode-display">Speed</span>
				</div>
			</div>
		</div>
	</div>

	<script type="module">
		import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs";

		const video = document.getElementById("webcam");
		const canvas = document.getElementById("overlay");
		const ctx = canvas.getContext("2d");
		const startBtn = document.getElementById("startBtn");
		const cameraStatus = document.getElementById("camera-status");
		const detectionStatus = document.getElementById("detection-status");
		const fpsCounter = document.getElementById("fps-counter");
		const handCounter = document.getElementById("hand-counter");
		const modeDisplay = document.getElementById("mode-display");
		
		// Modern color palette
		const colors = {
			primary: "#00d4ff",
			secondary: "#ff6b6b", 
			accent: "#4ecdc4",
			warning: "#ffa726",
			success: "#66bb6a",
			purple: "#ab47bc",
			pink: "#ec407a",
			orange: "#ff7043"
		};
		
		// Enhanced effects system
		const effects = {
			particles: [],
			trails: [],
			energy: [],
			sparks: [],
			ripples: [],
			connections: []
		};
		
		const hudState = { 
			t: 0, 
			lastVideoTime: -1, 
			frameCount: 0,
			lastFpsTime: 0,
			currentFps: 0
		};
		
		// Performance settings
		let MAX_HANDS = 1;
		let MODEL_VARIANT = "full";
		let VIDEO_WIDTH = 640;
		let VIDEO_HEIGHT = 480;
		let FRAME_RATE = 30;
		let handLandmarker = null;

		async function createDetector() {
			const filesetResolver = await FilesetResolver.forVisionTasks(
				"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
			);
			const modelUrl = "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task";
			handLandmarker = await HandLandmarker.createFromOptions(filesetResolver, {
				baseOptions: {
					modelAssetPath: modelUrl,
					delegate: "GPU",
				},
				numHands: MAX_HANDS,
				runningMode: "VIDEO",
			});
			detectionStatus.className = "status-dot active";
		}

		function resize() {
			const { videoWidth, videoHeight } = video;
			if (!videoWidth || !videoHeight) return;
			const dpr = Math.min(window.devicePixelRatio || 1, 2);
			canvas.width = Math.floor(videoWidth * dpr);
			canvas.height = Math.floor(videoHeight * dpr);
			canvas.style.width = videoWidth + "px";
			canvas.style.height = videoHeight + "px";
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			ctx.scale(dpr, dpr);
		}

		async function enableCamera() {
			try {
				await createDetector();
				const stream = await navigator.mediaDevices.getUserMedia({
					video: {
						facingMode: "user",
						width: { ideal: VIDEO_WIDTH },
						height: { ideal: VIDEO_HEIGHT },
						frameRate: { ideal: FRAME_RATE, max: FRAME_RATE }
					},
					audio: false
				});
				video.srcObject = stream;
				await video.play();
				resize();
				cameraStatus.className = "status-dot active";
				startBtn.innerHTML = '<span class="btn-icon">ðŸ“¹</span> Camera Active';
				startBtn.classList.add('active');
				requestAnimationFrame(loop);
			} catch (err) {
				console.error(err);
				cameraStatus.className = "status-dot error";
				startBtn.disabled = false;
			}
		}

		startBtn.addEventListener("click", () => {
			startBtn.disabled = true;
			enableCamera();
		});

		// Mode switching
		const modeSelect = document.getElementById("modeSelect");
		async function stopStream() {
			const s = video.srcObject;
			if (s && s.getTracks) s.getTracks().forEach(tr => tr.stop());
			video.srcObject = null;
			cameraStatus.className = "status-dot";
			detectionStatus.className = "status-dot";
		}

		async function restartPipeline() {
			await stopStream();
			try { handLandmarker && handLandmarker.close && handLandmarker.close(); } catch(e) {}
			handLandmarker = null;
			await enableCamera();
		}

		modeSelect.addEventListener("change", async () => {
			const preset = modeSelect.value;
			if (preset === "speed") {
				MODEL_VARIANT = "full";
				MAX_HANDS = 1;
				VIDEO_WIDTH = 640; VIDEO_HEIGHT = 480; FRAME_RATE = 30;
				modeDisplay.textContent = "Speed";
			} else {
				MODEL_VARIANT = "full";
				MAX_HANDS = 2;
				VIDEO_WIDTH = 960; VIDEO_HEIGHT = 720; FRAME_RATE = 30;
				modeDisplay.textContent = "Quality";
			}
			if (startBtn.disabled) await restartPipeline();
		});

		window.addEventListener("resize", resize);

		// Hand connection definitions
		const HAND_CONNECTIONS = [
			[0, 1], [1, 2], [2, 3], [3, 4], // Thumb
			[0, 5], [5, 6], [6, 7], [7, 8], // Index
			[0, 9], [9, 10], [10, 11], [11, 12], // Middle
			[0, 13], [13, 14], [14, 15], [15, 16], // Ring
			[0, 17], [17, 18], [18, 19], [19, 20], // Pinky
			[5, 9], [9, 13], [13, 17] // Cross connections
		];

		function toPx([x, y]) {
			return [x * video.videoWidth, y * video.videoHeight];
		}

		function drawModernHUDBase() {
			// Animated corner brackets
			const corners = [
				[20, 20], [video.videoWidth - 20, 20],
				[20, video.videoHeight - 20], [video.videoWidth - 20, video.videoHeight - 20]
			];
			
			ctx.strokeStyle = colors.primary;
			ctx.lineWidth = 3;
			ctx.lineCap = "round";
			ctx.shadowColor = colors.primary;
			ctx.shadowBlur = 10;
			
			corners.forEach(([x, y], i) => {
				const size = 30;
				const pulse = Math.sin(hudState.t * 0.05 + i * 0.5) * 0.3 + 0.7;
				ctx.globalAlpha = pulse;
				
				ctx.beginPath();
				if (i === 0) { // Top-left
					ctx.moveTo(x, y + size); ctx.lineTo(x, y); ctx.lineTo(x + size, y);
				} else if (i === 1) { // Top-right
					ctx.moveTo(x - size, y); ctx.lineTo(x, y); ctx.lineTo(x, y + size);
				} else if (i === 2) { // Bottom-left
					ctx.moveTo(x, y - size); ctx.lineTo(x, y); ctx.lineTo(x + size, y);
				} else { // Bottom-right
					ctx.moveTo(x - size, y); ctx.lineTo(x, y); ctx.lineTo(x, y - size);
				}
				ctx.stroke();
			});
			ctx.globalAlpha = 1;

			// Scanning lines effect
			const scanY = (hudState.t * 2) % video.videoHeight;
			ctx.strokeStyle = colors.accent;
			ctx.lineWidth = 1;
			ctx.globalAlpha = 0.3;
			ctx.beginPath();
			ctx.moveTo(0, scanY);
			ctx.lineTo(video.videoWidth, scanY);
			ctx.stroke();
			ctx.globalAlpha = 1;
		}

		function drawGlowRing(x, y, radius, rotation, color, intensity = 1) {
			ctx.save();
			ctx.translate(x, y);
			ctx.rotate(rotation);
			
			const gradient = ctx.createRadialGradient(0, 0, radius - 5, 0, 0, radius + 10);
			gradient.addColorStop(0, `${color}00`);
			gradient.addColorStop(0.7, `${color}${Math.floor(intensity * 255).toString(16).padStart(2, '0')}`);
			gradient.addColorStop(1, `${color}00`);
			
			ctx.strokeStyle = gradient;
			ctx.lineWidth = 4;
			ctx.beginPath();
			ctx.arc(0, 0, radius, 0, Math.PI * 2);
			ctx.stroke();
			
			// Inner ring
			ctx.strokeStyle = color;
			ctx.lineWidth = 2;
			ctx.shadowColor = color;
			ctx.shadowBlur = 15;
			ctx.beginPath();
			ctx.arc(0, 0, radius, 0, Math.PI * 1.5);
			ctx.stroke();
			
			ctx.restore();
		}

		function drawFingertipHUD(x, y, fingerIndex, t) {
			const colorIndex = fingerIndex % Object.keys(colors).length;
			const color = Object.values(colors)[colorIndex];
			
			drawGlowRing(x, y, 15, t * 0.1 + fingerIndex, color, 0.8);
			
			// Pulsing center dot
			const pulse = Math.sin(t * 0.15 + fingerIndex) * 0.3 + 0.7;
			ctx.fillStyle = color;
			ctx.shadowColor = color;
			ctx.shadowBlur = 20;
			ctx.beginPath();
			ctx.arc(x, y, 4 * pulse, 0, Math.PI * 2);
			ctx.fill();
			ctx.shadowBlur = 0;
			
			// Add ripple effect
			if (Math.random() < 0.1) {
				effects.ripples.push({
					x, y, radius: 5, maxRadius: 40, color, life: 30
				});
			}
		}

		function drawPalmHUD(landmarks, t) {
			const palmPoints = [0, 5, 9, 13, 17].map(i => toPx([landmarks[i].x, landmarks[i].y]));
			const [cx, cy] = palmPoints.reduce(([sx, sy], [x, y]) => [sx + x, sy + y], [0, 0])
				.map(sum => sum / palmPoints.length);

			// Main palm ring
			drawGlowRing(cx, cy, 35, t * 0.08, colors.primary, 1);
			
			// Connection lines to palm points
			ctx.strokeStyle = colors.secondary;
			ctx.lineWidth = 2;
			ctx.shadowColor = colors.secondary;
			ctx.shadowBlur = 10;
			ctx.lineCap = "round";
			
			palmPoints.forEach(([x, y], i) => {
				const alpha = Math.sin(t * 0.1 + i * 0.8) * 0.3 + 0.7;
				ctx.globalAlpha = alpha;
				ctx.beginPath();
				ctx.moveTo(cx, cy);
				ctx.lineTo(x, y);
				ctx.stroke();
			});
			ctx.globalAlpha = 1;

			// Data display
			ctx.font = "12px 'SF Mono', 'Monaco', monospace";
			ctx.fillStyle = colors.accent;
			ctx.shadowColor = colors.accent;
			ctx.shadowBlur = 8;
			ctx.fillText(`PALM_${Math.floor(t % 1000)}`, cx - 30, cy + 55);
		}

		function drawModernSkeleton(landmarks) {
			// Multi-colored skeleton with glow effects
			HAND_CONNECTIONS.forEach(([a, b], connectionIndex) => {
				const pa = toPx([landmarks[a].x, landmarks[a].y]);
				const pb = toPx([landmarks[b].x, landmarks[b].y]);
				
				// Determine color based on finger
				let color = colors.primary;
				if (connectionIndex < 4) color = colors.secondary; // Thumb
				else if (connectionIndex < 8) color = colors.accent; // Index
				else if (connectionIndex < 12) color = colors.warning; // Middle
				else if (connectionIndex < 16) color = colors.success; // Ring
				else if (connectionIndex < 20) color = colors.purple; // Pinky
				
				ctx.strokeStyle = color;
				ctx.lineWidth = 3;
				ctx.lineCap = "round";
				ctx.shadowColor = color;
				ctx.shadowBlur = 12;
				
				ctx.beginPath();
				ctx.moveTo(pa[0], pa[1]);
				ctx.lineTo(pb[0], pb[1]);
				ctx.stroke();
				
				// Add energy trails
				effects.trails.push({
					x: pa[0], y: pa[1], vx: (pb[0] - pa[0]) * 0.1, vy: (pb[1] - pa[1]) * 0.1,
					life: 25, color, alpha: 0.6
				});
			});
		}

		function drawJointNodes(landmarks, t) {
			landmarks.forEach((landmark, i) => {
				const [x, y] = toPx([landmark.x, landmark.y]);
				const isKeyPoint = [0, 4, 8, 12, 16, 20].includes(i);
				const radius = isKeyPoint ? 6 : 4;
				
				// Color based on joint type
				let color = colors.primary;
				if (i === 0) color = colors.pink; // Wrist
				else if (i <= 4) color = colors.secondary; // Thumb
				else if (i <= 8) color = colors.accent; // Index
				else if (i <= 12) color = colors.warning; // Middle
				else if (i <= 16) color = colors.success; // Ring
				else color = colors.purple; // Pinky
				
				const pulse = Math.sin(t * 0.2 + i * 0.3) * 0.4 + 0.6;
				
				ctx.fillStyle = color;
				ctx.shadowColor = color;
				ctx.shadowBlur = 15;
				ctx.beginPath();
				ctx.arc(x, y, radius * pulse, 0, Math.PI * 2);
				ctx.fill();
				
				if (isKeyPoint) {
					drawGlowRing(x, y, 12, t * 0.15 + i, color, pulse);
				}
				
				// Particle generation
				if (Math.random() < 0.2) {
					effects.energy.push({
						x: x + (Math.random() - 0.5) * 20,
						y: y + (Math.random() - 0.5) * 20,
						vx: (Math.random() - 0.5) * 3,
						vy: (Math.random() - 0.5) * 3,
						life: 40,
						color,
						size: Math.random() * 3 + 2
					});
				}
			});
		}

		// Landmark smoothing
		const prevByHandIndex = new Map();
		function smoothLandmarks(raw, handIndex) {
			const alpha = 0.4;
			const prev = prevByHandIndex.get(handIndex) || raw;
			const smoothed = raw.map((p, i) => ({
				x: prev[i] ? prev[i].x * (1 - alpha) + p.x * alpha : p.x,
				y: prev[i] ? prev[i].y * (1 - alpha) + p.y * alpha : p.y,
				z: p.z
			}));
			prevByHandIndex.set(handIndex, smoothed);
			return smoothed;
		}

		function updateEffects() {
			// Update energy particles
			effects.energy = effects.energy.filter(p => {
				p.x += p.vx;
				p.y += p.vy;
				p.vx *= 0.98;
				p.vy *= 0.98;
				p.life--;
				return p.life > 0;
			});
			
			// Update trails
			effects.trails = effects.trails.filter(t => {
				t.x += t.vx;
				t.y += t.vy;
				t.life--;
				t.alpha *= 0.96;
				return t.life > 0 && t.alpha > 0.1;
			});
			
			// Update ripples
			effects.ripples = effects.ripples.filter(r => {
				r.radius += (r.maxRadius - r.radius) * 0.15;
				r.life--;
				return r.life > 0;
			});
			
			// Add ambient particles
			if (Math.random() < 0.15) {
				effects.particles.push({
					x: Math.random() * video.videoWidth,
					y: Math.random() * video.videoHeight,
					vx: (Math.random() - 0.5) * 0.8,
					vy: (Math.random() - 0.5) * 0.8,
					life: 80,
					size: Math.random() * 2 + 1,
					color: Object.values(colors)[Math.floor(Math.random() * Object.values(colors).length)]
				});
			}
			
			effects.particles = effects.particles.filter(p => {
				p.x += p.vx;
				p.y += p.vy;
				p.life--;
				return p.life > 0 && p.x > -50 && p.x < video.videoWidth + 50 && p.y > -50 && p.y < video.videoHeight + 50;
			});
		}
		
		function drawEffects() {
			// Draw ripples
			effects.ripples.forEach(r => {
				ctx.save();
				ctx.globalAlpha = r.life / 30;
				ctx.strokeStyle = r.color;
				ctx.lineWidth = 2;
				ctx.shadowColor = r.color;
				ctx.shadowBlur = 10;
				ctx.beginPath();
				ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
				ctx.stroke();
				ctx.restore();
			});
			
			// Draw energy particles
			effects.energy.forEach(p => {
				ctx.save();
				ctx.globalAlpha = p.life / 40;
				ctx.fillStyle = p.color;
				ctx.shadowColor = p.color;
				ctx.shadowBlur = 15;
				ctx.beginPath();
				ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
				ctx.fill();
				ctx.restore();
			});
			
			// Draw trails
			effects.trails.forEach(t => {
				ctx.save();
				ctx.globalAlpha = t.alpha;
				ctx.fillStyle = t.color;
				ctx.shadowColor = t.color;
				ctx.shadowBlur = 10;
				ctx.beginPath();
				ctx.arc(t.x, t.y, 3, 0, Math.PI * 2);
				ctx.fill();
				ctx.restore();
			});
			
			// Draw ambient particles
			effects.particles.forEach(p => {
				ctx.save();
				ctx.globalAlpha = p.life / 80;
				ctx.fillStyle = p.color;
				ctx.shadowColor = p.color;
				ctx.shadowBlur = 8;
				ctx.beginPath();
				ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
				ctx.fill();
				ctx.restore();
			});
		}
		
		function updateFPS() {
			hudState.frameCount++;
			const now = performance.now();
			if (now - hudState.lastFpsTime >= 1000) {
				hudState.currentFps = hudState.frameCount;
				hudState.frameCount = 0;
				hudState.lastFpsTime = now;
				fpsCounter.textContent = hudState.currentFps;
			}
		}

		function loop(t) {
			if (!handLandmarker) return;
			hudState.t = t * 0.08;
			
			updateFPS();
			
			if (video.currentTime === hudState.lastVideoTime) {
				requestAnimationFrame(loop);
				return;
			}
			hudState.lastVideoTime = video.currentTime;
			
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			drawModernHUDBase();
			updateEffects();
			drawEffects();

			const result = handLandmarker.detectForVideo(video, performance.now());
			const hands = result.landmarks || [];
			handCounter.textContent = hands.length;
			
			for (let hi = 0; hi < hands.length; hi++) {
				const hand = smoothLandmarks(hands[hi], hi);
				drawModernSkeleton(hand);
				drawPalmHUD(hand, hudState.t);
				drawJointNodes(hand, hudState.t);
				
				// Enhanced fingertips
				[4, 8, 12, 16, 20].forEach((fingerIndex, i) => {
					const [x, y] = toPx([hand[fingerIndex].x, hand[fingerIndex].y]);
					drawFingertipHUD(x, y, i, hudState.t);
				});
			}

			requestAnimationFrame(loop);
		}
	</script>
</body>
</html>